<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pip | Team Whiteboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background-color: #f5f5f5;
            overflow: hidden;
        }

        #whiteboard {
            display: block;
            background-color: white;
            cursor: crosshair;
            touch-action: none;
        }

        .toolbar {
            position: fixed;
            top: 10px;
            left: 10px;
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 100;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .clear-btn {
            background: #ff4444;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .clear-btn:hover {
            background: #cc3333;
        }

        .status {
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 12px;
            background: #e0e0e0;
            color: #666;
        }

        .status.live {
            background: #90EE90;
            color: #006400;
        }
    </style>
</head>
<body>
    <div class="toolbar">
        <button class="clear-btn" onclick="clearAll()">Clear</button>
        <div class="status" id="status">Loading...</div>
    </div>
    
    <canvas id="whiteboard"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/supabase-js/2.38.0/supabase.min.js"></script>
    <script>
        // Supabase credentials
        const SUPABASE_URL = 'https://cdzcggonkteatjnzvyfs.supabase.co';
        const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNkemNnZ29ua3RlYXRqbnp2eWZzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTg2NzU1MDgsImV4cCI6MjA3NDI1MTUwOH0.K5X5S5ArM1W_bF04mZX7D4DC3uRxQtxl39Z5YWOZgDk';
        
        const canvas = document.getElementById('whiteboard');
        const ctx = canvas.getContext('2d');
        let isDrawing = false;
        let currentPath = [];
        let supabase = null;

        // Setup canvas
        function setupCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            ctx.strokeStyle = '#3d3d3d';
            ctx.lineWidth = 5;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
        }

        // Initialize everything
        async function init() {
            setupCanvas();
            
            if (SUPABASE_URL === 'YOUR_SUPABASE_URL_HERE') {
                document.getElementById('status').textContent = 'Add Supabase credentials';
                return;
            }
            
            try {
                supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
                await loadExistingDrawings();
                subscribeToUpdates();
                document.getElementById('status').textContent = 'Live';
                document.getElementById('status').className = 'status live';
            } catch (error) {
                document.getElementById('status').textContent = 'Connection failed';
                console.error('Init error:', error);
            }
        }

        // Load existing drawings from database
        async function loadExistingDrawings() {
            const { data, error } = await supabase
                .from('drawing_strokes')
                .select('stroke_data')
                .order('created_at');

            if (error) {
                console.error('Load error:', error);
                return;
            }

            data.forEach(stroke => drawPath(stroke.stroke_data));
        }

        // Subscribe to real-time updates
        function subscribeToUpdates() {
            supabase
                .channel('whiteboard')
                .on('postgres_changes', {
                    event: 'INSERT',
                    schema: 'public',
                    table: 'drawing_strokes'
                }, (payload) => {
                    drawPath(payload.new.stroke_data);
                })
                .on('postgres_changes', {
                    event: 'DELETE',
                    schema: 'public',
                    table: 'drawing_strokes'
                }, () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                })
                .subscribe();
        }

        // Draw a path (smooth curves)
        function drawPath(path) {
            if (path.length < 2) return;

            ctx.beginPath();
            ctx.moveTo(path[0].x, path[0].y);

            for (let i = 1; i < path.length - 2; i++) {
                const xc = (path[i].x + path[i + 1].x) / 2;
                const yc = (path[i].y + path[i + 1].y) / 2;
                ctx.quadraticCurveTo(path[i].x, path[i].y, xc, yc);
            }
            
            if (path.length > 2) {
                ctx.quadraticCurveTo(
                    path[path.length - 2].x, 
                    path[path.length - 2].y, 
                    path[path.length - 1].x, 
                    path[path.length - 1].y
                );
            } else {
                ctx.lineTo(path[1].x, path[1].y);
            }
            
            ctx.stroke();
        }

        // Save stroke to database
        async function saveStroke(path) {
            if (!supabase || path.length === 0) return;
            
            await supabase.from('drawing_strokes').insert({
                stroke_data: path
            });
        }

        // Clear all drawings
        async function clearAll() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (supabase) {
                await supabase.from('drawing_strokes').delete().neq('id', 0);
            }
        }

        // Get mouse/touch coordinates
        function getCoords(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        // Drawing functions
        function startDrawing(e) {
            e.preventDefault();
            isDrawing = true;
            const coords = getCoords(e);
            currentPath = [coords];
        }

        function draw(e) {
            if (!isDrawing) return;
            e.preventDefault();
            
            const coords = getCoords(e);
            currentPath.push(coords);
            
            // Draw locally in real-time
            if (currentPath.length > 1) {
                ctx.beginPath();
                const prev = currentPath[currentPath.length - 2];
                ctx.moveTo(prev.x, prev.y);
                ctx.lineTo(coords.x, coords.y);
                ctx.stroke();
            }
        }

        function stopDrawing(e) {
            if (!isDrawing) return;
            e.preventDefault();
            isDrawing = false;
            
            if (currentPath.length > 1) {
                saveStroke(currentPath);
            }
            currentPath = [];
        }

        // Event listeners
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);

        canvas.addEventListener('touchstart', startDrawing);
        canvas.addEventListener('touchmove', draw);
        canvas.addEventListener('touchend', stopDrawing);

        window.addEventListener('resize', setupCanvas);
        
        // Prevent scrolling
        document.body.addEventListener('touchstart', e => e.preventDefault());
        document.body.addEventListener('touchend', e => e.preventDefault());
        document.body.addEventListener('touchmove', e => e.preventDefault());

        // Start the app
        init();
    </script>
</body>
</html>
